import { promises as fs } from 'fs';
import { join } from 'path';
import { env } from 'process';
import { pathToFileURL } from 'url';
import del from 'del';
import { wrapBundleError } from '../bundle_error.js';
import { getFileHash } from '../utils/sha256.js';
const BOOTSTRAP_LATEST = 'https://62f5f45fbc76ed0009624267--edge.netlify.com/bootstrap/index-combined.ts';
const bundleJS = async ({ buildID, debug, deno, distDirectory, functions, importMap, }) => {
    const stage2Path = await generateStage2({ distDirectory, functions, fileName: `${buildID}-pre.js` });
    const extension = '.js';
    const jsBundlePath = join(distDirectory, `${buildID}${extension}`);
    const flags = [`--import-map=${importMap.toDataURL()}`];
    if (!debug) {
        flags.push('--quiet');
    }
    try {
        await deno.run(['bundle', ...flags, stage2Path, jsBundlePath], { pipeOutput: true });
    }
    catch (error) {
        throw wrapBundleError(error, { format: 'javascript' });
    }
    await fs.unlink(stage2Path);
    const hash = await getFileHash(jsBundlePath);
    return { extension, format: 'js', hash };
};
const defaultFormatExportTypeError = (name) => `The Edge Function "${name}" has failed to load. Does it have a function as the default export?`;
const defaultFormatImpoortError = (name) => `There was an error with Edge Function "${name}".`;
const generateStage2 = async ({ distDirectory, fileName, formatExportTypeError, formatImportError, functions, type = 'production', }) => {
    await del(distDirectory, { force: true });
    await fs.mkdir(distDirectory, { recursive: true });
    const entryPoint = type === 'local'
        ? getLocalEntryPoint(functions, { formatExportTypeError, formatImportError })
        : getProductionEntryPoint(functions);
    const stage2Path = join(distDirectory, fileName);
    await fs.writeFile(stage2Path, entryPoint);
    return stage2Path;
};
const getBootstrapURL = () => { var _a; return (_a = env.NETLIFY_EDGE_BOOTSTRAP) !== null && _a !== void 0 ? _a : BOOTSTRAP_LATEST; };
// For the local development environment, we import the user functions with
// dynamic imports to gracefully handle the case where the file doesn't have
// a valid default export.
const getLocalEntryPoint = (functions, { formatExportTypeError = defaultFormatExportTypeError, formatImportError = defaultFormatImpoortError, }) => {
    const bootImport = `import { boot } from "${getBootstrapURL()}";`;
    const declaration = `const functions = {};`;
    const imports = functions.map((func) => `
  try {
    const { default: func } = await import("${pathToFileURL(func.path)}");

    if (typeof func === "function") {
      functions["${func.name}"] = func;
    } else {
      console.log(${JSON.stringify(formatExportTypeError(func.name))});
    }
  } catch (error) {
    console.log(${JSON.stringify(formatImportError(func.name))});
    console.error(error);
  }
  `);
    const bootCall = `boot(functions);`;
    return [bootImport, declaration, ...imports, bootCall].join('\n\n');
};
const getProductionEntryPoint = (functions) => {
    const bootImport = `import { boot } from "${getBootstrapURL()}";`;
    const lines = functions.map((func, index) => {
        const importName = `func${index}`;
        const exportLine = `"${func.name}": ${importName}`;
        const url = pathToFileURL(func.path);
        return {
            exportLine,
            importLine: `import ${importName} from "${url}";`,
        };
    });
    const importLines = lines.map(({ importLine }) => importLine).join('\n');
    const exportLines = lines.map(({ exportLine }) => exportLine).join(', ');
    const exportDeclaration = `const functions = {${exportLines}};`;
    const defaultExport = 'boot(functions);';
    return [bootImport, importLines, exportDeclaration, defaultExport].join('\n\n');
};
export { bundleJS as bundle, generateStage2, getBootstrapURL };
