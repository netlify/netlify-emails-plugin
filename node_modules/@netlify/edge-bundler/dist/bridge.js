import { promises as fs } from 'fs';
import path from 'path';
import process from 'process';
import { execa } from 'execa';
import pathKey from 'path-key';
import semver from 'semver';
import { download } from './downloader.js';
import { getPathInHome } from './home_path.js';
import { getLogger } from './logger.js';
import { getBinaryExtension } from './platform.js';
const DENO_VERSION_FILE = 'version.txt';
const DENO_VERSION_RANGE = '^1.20.3';
class DenoBridge {
    constructor(options) {
        var _a, _b, _c, _d, _e;
        this.cacheDirectory = (_a = options.cacheDirectory) !== null && _a !== void 0 ? _a : getPathInHome('deno-cli');
        this.debug = (_b = options.debug) !== null && _b !== void 0 ? _b : false;
        this.denoDir = options.denoDir;
        this.logger = (_c = options.logger) !== null && _c !== void 0 ? _c : getLogger(undefined, options.debug);
        this.onAfterDownload = options.onAfterDownload;
        this.onBeforeDownload = options.onBeforeDownload;
        this.useGlobal = (_d = options.useGlobal) !== null && _d !== void 0 ? _d : true;
        this.versionRange = (_e = options.versionRange) !== null && _e !== void 0 ? _e : DENO_VERSION_RANGE;
    }
    async downloadBinary() {
        var _a, _b, _c;
        await ((_a = this.onBeforeDownload) === null || _a === void 0 ? void 0 : _a.call(this));
        await this.ensureCacheDirectory();
        this.logger.system(`Downloading Deno CLI to ${this.cacheDirectory}`);
        const binaryPath = await download(this.cacheDirectory, this.versionRange, this.logger);
        const downloadedVersion = await this.getBinaryVersion(binaryPath);
        // We should never get here, because it means that `DENO_VERSION_RANGE` is
        // a malformed semver range. If this does happen, let's throw an error so
        // that the tests catch it.
        if (downloadedVersion === undefined) {
            const error = new Error('There was a problem setting up the Edge Functions environment. To try a manual installation, visit https://ntl.fyi/install-deno.');
            await ((_b = this.onAfterDownload) === null || _b === void 0 ? void 0 : _b.call(this, error));
            this.logger.system('Could not run downloaded Deno CLI', error);
            throw error;
        }
        await this.writeVersionFile(downloadedVersion);
        await ((_c = this.onAfterDownload) === null || _c === void 0 ? void 0 : _c.call(this));
        return binaryPath;
    }
    async getBinaryVersion(binaryPath) {
        try {
            const { stdout } = await execa(binaryPath, ['--version']);
            const version = stdout.match(/^deno ([\d.]+)/);
            if (!version) {
                this.logger.system(`getBinaryVersion no version found. binaryPath ${binaryPath}`);
                return;
            }
            return version[1];
        }
        catch { }
    }
    async getCachedBinary() {
        const versionFilePath = path.join(this.cacheDirectory, DENO_VERSION_FILE);
        let cachedVersion;
        try {
            cachedVersion = await fs.readFile(versionFilePath, 'utf8');
        }
        catch (error) {
            this.logger.system('Error getting cached binary', error);
            return;
        }
        if (!semver.satisfies(cachedVersion, this.versionRange)) {
            this.logger.system(`semver not satisfied. cachedVersion: ${cachedVersion}, versionRange: ${this.versionRange}`);
            return;
        }
        const binaryName = `deno${getBinaryExtension()}`;
        return path.join(this.cacheDirectory, binaryName);
    }
    async getGlobalBinary() {
        if (!this.useGlobal) {
            return;
        }
        const globalBinaryName = 'deno';
        const globalVersion = await this.getBinaryVersion(globalBinaryName);
        if (globalVersion === undefined || !semver.satisfies(globalVersion, this.versionRange)) {
            this.logger.system(`No globalVersion or semver not satisfied. globalVersion: ${globalVersion}, versionRange: ${this.versionRange}`);
            return;
        }
        return globalBinaryName;
    }
    getRemoteBinary() {
        if (this.currentDownload === undefined) {
            this.currentDownload = this.downloadBinary();
        }
        return this.currentDownload;
    }
    static runWithBinary(binaryPath, args, options, pipeOutput) {
        var _a, _b;
        const runDeno = execa(binaryPath, args, options);
        if (pipeOutput) {
            (_a = runDeno.stdout) === null || _a === void 0 ? void 0 : _a.pipe(process.stdout);
            (_b = runDeno.stderr) === null || _b === void 0 ? void 0 : _b.pipe(process.stderr);
        }
        return runDeno;
    }
    async writeVersionFile(version) {
        await this.ensureCacheDirectory();
        const versionFilePath = path.join(this.cacheDirectory, DENO_VERSION_FILE);
        await fs.writeFile(versionFilePath, version);
    }
    async ensureCacheDirectory() {
        await fs.mkdir(this.cacheDirectory, { recursive: true });
    }
    async getBinaryPath() {
        const globalPath = await this.getGlobalBinary();
        if (globalPath !== undefined) {
            this.logger.system('Using global installation of Deno CLI');
            return { global: true, path: globalPath };
        }
        const cachedPath = await this.getCachedBinary();
        if (cachedPath !== undefined) {
            this.logger.system('Using cached Deno CLI from', cachedPath);
            return { global: false, path: cachedPath };
        }
        const downloadedPath = await this.getRemoteBinary();
        return { global: false, path: downloadedPath };
    }
    getEnvironmentVariables(inputEnv = {}) {
        const env = { ...inputEnv };
        if (this.denoDir !== undefined) {
            env.DENO_DIR = this.denoDir;
        }
        // Ensure PATH is always set as otherwise we are not able to find the global deno binary
        env[pathKey()] = inputEnv[pathKey({ env: inputEnv })] || process.env[pathKey()];
        return env;
    }
    // Runs the Deno CLI in the background and returns a reference to the child
    // process, awaiting its execution.
    async run(args, { pipeOutput, env: inputEnv, extendEnv = true } = {}) {
        const { path: binaryPath } = await this.getBinaryPath();
        const env = this.getEnvironmentVariables(inputEnv);
        const options = { env, extendEnv };
        return DenoBridge.runWithBinary(binaryPath, args, options, pipeOutput);
    }
    // Runs the Deno CLI in the background, assigning a reference of the child
    // process to a `ps` property in the `ref` argument, if one is supplied.
    async runInBackground(args, ref, { pipeOutput, env: inputEnv, extendEnv = true } = {}) {
        const { path: binaryPath } = await this.getBinaryPath();
        const env = this.getEnvironmentVariables(inputEnv);
        const options = { env, extendEnv };
        const ps = DenoBridge.runWithBinary(binaryPath, args, options, pipeOutput);
        if (ref !== undefined) {
            // eslint-disable-next-line no-param-reassign
            ref.ps = ps;
        }
    }
}
export { DenoBridge };
