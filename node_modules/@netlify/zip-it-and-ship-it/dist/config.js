"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfigForFunction = void 0;
const merge_options_1 = __importDefault(require("merge-options"));
const matching_js_1 = require("./utils/matching.js");
const getConfigForFunction = ({ config, func, }) => {
    if (!config) {
        return {};
    }
    // It's safe to mutate the array because it's local to this function.
    const matches = Object.keys(config)
        .filter((expression) => (0, matching_js_1.minimatch)(func.name, expression))
        .map((expression) => {
        const wildcardCount = [...expression].filter((char) => char === '*').length;
        // The weight increases with the number of hardcoded (i.e. non-wildcard)
        // characters â€” e.g. "netlify" has a higher weight than "net*". We do a
        // subtraction of 1 if there is at least one wildcard character, so that
        // "netlify" has a higher weight than "netlify*".
        const weight = expression.length - wildcardCount - (wildcardCount === 0 ? 0 : 1);
        return {
            expression,
            weight,
        };
    })
        .sort(({ weight: weightA }, { weight: weightB }) => weightA - weightB)
        .map(({ expression }) => config[expression]);
    return merge_options_1.default.apply({ concatArrays: true, ignoreUndefined: true }, matches);
};
exports.getConfigForFunction = getConfigForFunction;
//# sourceMappingURL=config.js.map