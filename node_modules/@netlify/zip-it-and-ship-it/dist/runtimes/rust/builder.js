"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const tmp_promise_1 = __importDefault(require("tmp-promise"));
const toml_1 = __importDefault(require("toml"));
const error_js_1 = require("../../utils/error.js");
const shell_js_1 = require("../../utils/shell.js");
const constants_js_1 = require("./constants.js");
const build = async ({ config, name, srcDir }) => {
    const functionName = (0, path_1.basename)(srcDir);
    try {
        await installToolchainOnce();
    }
    catch (error) {
        throw error_js_1.FunctionBundlingUserError.addCustomErrorInfo(error, { functionName, runtime: 'rs' });
    }
    const targetDirectory = await getTargetDirectory({ config, name });
    await cargoBuild({ functionName, srcDir, targetDirectory });
    // By default, the binary will have the same name as the crate and there's no
    // way to override it (https://github.com/rust-lang/cargo/issues/1706). We
    // must extract the crate name from the manifest and use it to form the path
    // to the binary.
    const manifest = await fs_1.promises.readFile((0, path_1.join)(srcDir, constants_js_1.MANIFEST_NAME), 'utf8');
    const { package: { name: packageName }, } = toml_1.default.parse(manifest);
    const binaryPath = (0, path_1.join)(targetDirectory, constants_js_1.BUILD_TARGET, 'release', packageName);
    const stat = await fs_1.promises.lstat(binaryPath);
    return {
        path: binaryPath,
        stat,
    };
};
exports.build = build;
const cargoBuild = async ({ functionName, srcDir, targetDirectory, }) => {
    try {
        await shell_js_1.shellUtils.runCommand('cargo', ['build', '--target', constants_js_1.BUILD_TARGET, '--release'], {
            cwd: srcDir,
            env: {
                CARGO_TARGET_DIR: targetDirectory,
            },
        });
    }
    catch (error) {
        const hasToolchain = await checkRustToolchain();
        if (hasToolchain) {
            console.error(`Could not compile Rust function ${functionName}:\n`);
        }
        else {
            error.message =
                'There is no Rust toolchain installed. Visit https://ntl.fyi/missing-rust-toolchain for more information.';
        }
        throw error_js_1.FunctionBundlingUserError.addCustomErrorInfo(error, { functionName, runtime: 'rs' });
    }
};
const checkRustToolchain = async () => {
    try {
        await shell_js_1.shellUtils.runCommand('cargo', ['-V']);
        return true;
    }
    catch {
        return false;
    }
};
// Returns the path of the Cargo target directory.
const getTargetDirectory = async ({ config, name }) => {
    const { rustTargetDirectory } = config;
    // If the config includes a `rustTargetDirectory` path, we'll use that.
    if (rustTargetDirectory) {
        // We replace the [name] placeholder with the name of the function.
        const path = rustTargetDirectory.replace(/\[name]/g, name);
        await fs_1.promises.mkdir(path, { recursive: true });
        return path;
    }
    // If the directory hasn't been configured, we'll use a temporary directory.
    const { path } = await tmp_promise_1.default.dir();
    return path;
};
let toolchainInstallation;
// Sets the default toolchain and installs the build target defined in
// `BUILD_TARGET`. The Promise is saved to `toolchainInstallation`, so
// that we run the command just once for multiple Rust functions.
const installToolchain = async () => {
    await shell_js_1.shellUtils.runCommand('rustup', ['default', 'stable']);
    await shell_js_1.shellUtils.runCommand('rustup', ['target', 'add', constants_js_1.BUILD_TARGET]);
};
const installToolchainOnce = () => {
    if (toolchainInstallation === undefined) {
        toolchainInstallation = installToolchain();
    }
    return toolchainInstallation;
};
//# sourceMappingURL=builder.js.map