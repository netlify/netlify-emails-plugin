"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const cp_file_1 = __importDefault(require("cp-file"));
const fs_js_1 = require("../../utils/fs.js");
const non_nullable_js_1 = require("../../utils/non_nullable.js");
const zip_binary_js_1 = require("../../zip_binary.js");
const detect_runtime_js_1 = require("../detect_runtime.js");
const builder_js_1 = require("./builder.js");
const detectGoFunction = async ({ fsCache, path }) => {
    const stat = await (0, fs_js_1.cachedLstat)(fsCache, path);
    if (!stat.isDirectory()) {
        return;
    }
    const directoryName = (0, path_1.basename)(path);
    // @ts-expect-error TODO: The `makeCachedFunction` abstraction is causing the
    // return value of `readdir` to be incorrectly typed.
    const files = (await (0, fs_js_1.cachedReaddir)(fsCache, path));
    const mainFileName = [`${directoryName}.go`, 'main.go'].find((name) => files.includes(name));
    if (mainFileName === undefined) {
        return;
    }
    return mainFileName;
};
const findFunctionsInPaths = async function ({ featureFlags, fsCache, paths }) {
    const functions = await Promise.all(paths.map((path) => findFunctionInPath({ featureFlags, fsCache, path })));
    return functions.filter(non_nullable_js_1.nonNullable);
};
const findFunctionInPath = async function ({ fsCache, path }) {
    const runtime = await (0, detect_runtime_js_1.detectBinaryRuntime)({ fsCache, path });
    if (runtime === 'go') {
        return processBinary({ fsCache, path });
    }
    const goSourceFile = await detectGoFunction({ fsCache, path });
    if (goSourceFile) {
        return processSource({ fsCache, mainFile: goSourceFile, path });
    }
};
const processBinary = async ({ fsCache, path }) => {
    const stat = (await (0, fs_js_1.cachedLstat)(fsCache, path));
    const extension = (0, path_1.extname)(path);
    const filename = (0, path_1.basename)(path);
    const name = (0, path_1.basename)(path, (0, path_1.extname)(path));
    return {
        extension,
        filename,
        mainFile: path,
        name,
        srcDir: (0, path_1.dirname)(path),
        srcPath: path,
        stat,
    };
};
const processSource = async ({ fsCache, mainFile, path, }) => {
    // TODO: This `stat` value is not going to be used, but we need it to satisfy
    // the `FunctionSource` interface. We should revisit whether `stat` should be
    // part of that interface in the first place, or whether we could compute it
    // downstream when needed (maybe using the FS cache as an optimisation).
    const stat = (await (0, fs_js_1.cachedLstat)(fsCache, path));
    const filename = (0, path_1.basename)(path);
    const extension = (0, path_1.extname)(mainFile);
    const name = (0, path_1.basename)(path, (0, path_1.extname)(path));
    return {
        extension,
        filename,
        mainFile: (0, path_1.join)(path, mainFile),
        name,
        srcDir: path,
        srcPath: path,
        stat,
    };
};
const zipFunction = async function ({ config, destFolder, filename, mainFile, srcDir, srcPath, stat }) {
    const destPath = (0, path_1.join)(destFolder, filename);
    const isSource = (0, path_1.extname)(mainFile) === '.go';
    let binary = {
        path: srcPath,
        stat,
    };
    // If we're building a Go function from source, we call the build method and
    // update `binary` to point to the newly-created binary.
    if (isSource) {
        const { stat: binaryStat } = await (0, builder_js_1.build)({ destPath, mainFile, srcDir });
        binary = {
            path: destPath,
            stat: binaryStat,
        };
    }
    // If `zipGo` is enabled, we create a zip archive with the Go binary and the
    // toolchain file.
    if (config.zipGo) {
        const zipPath = `${destPath}.zip`;
        const zipOptions = {
            destPath: zipPath,
            filename: (0, path_1.basename)(destPath),
            runtime,
        };
        await (0, zip_binary_js_1.zipBinary)({ ...zipOptions, srcPath: binary.path, stat: binary.stat });
        return { config, path: zipPath };
    }
    // We don't need to zip the binary, so we can just copy it to the right path.
    // We do this only if we're not building from source, as otherwise the build
    // step already handled that.
    if (!isSource) {
        await (0, cp_file_1.default)(binary.path, destPath);
    }
    return { config, path: destPath };
};
const runtime = { findFunctionsInPaths, findFunctionInPath, name: 'go', zipFunction };
exports.default = runtime;
//# sourceMappingURL=index.js.map