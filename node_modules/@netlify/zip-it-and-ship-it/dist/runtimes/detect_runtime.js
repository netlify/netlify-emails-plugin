"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectBinaryRuntime = void 0;
const binary_info_1 = require("@netlify/binary-info");
const fs_js_1 = require("../utils/fs.js");
const isValidFunctionBinary = (info) => info.arch === binary_info_1.Arch.Amd64 && info.platform === binary_info_1.Platform.Linux;
const warnIncompatibleBinary = function (path, binaryInfo) {
    if (!global.ZISI_CLI) {
        console.warn(`
Found incompatible prebuilt function binary in ${path}.
The binary needs to be built for Linux/Amd64, but it was built for ${binary_info_1.Platform[binaryInfo.platform]}/${binary_info_1.Arch[binaryInfo.arch]}`);
    }
    return undefined;
};
// Try to guess the runtime by inspecting the binary file.
const detectBinaryRuntime = async function ({ fsCache, path, }) {
    try {
        const buffer = await (0, fs_js_1.cachedReadFile)(fsCache, path);
        // We're using the Type Assertion because the `cachedReadFile` abstraction
        // loses part of the return type information. We can safely say it's a
        // Buffer in this case because we're not specifying an encoding.
        const binaryInfo = (0, binary_info_1.detect)(buffer);
        if (!isValidFunctionBinary(binaryInfo)) {
            return warnIncompatibleBinary(path, binaryInfo);
        }
        switch (binaryInfo.runtime) {
            case binary_info_1.Runtime.Go:
                return 'go';
            case binary_info_1.Runtime.Rust:
                return 'rs';
            default:
                return undefined;
        }
    }
    catch {
        // Possible errors are: non binary files, arch/platforms not supported by binary-info, path is directory
    }
};
exports.detectBinaryRuntime = detectBinaryRuntime;
//# sourceMappingURL=detect_runtime.js.map