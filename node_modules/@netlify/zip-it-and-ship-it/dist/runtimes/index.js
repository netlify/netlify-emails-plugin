"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFunctionFromPath = exports.getFunctionsFromPaths = void 0;
const path_1 = require("path");
const config_js_1 = require("../config.js");
const feature_flags_js_1 = require("../feature_flags.js");
const index_js_1 = __importDefault(require("./go/index.js"));
const index_js_2 = __importDefault(require("./node/index.js"));
const index_js_3 = __importDefault(require("./rust/index.js"));
/**
 * Finds functions for a list of paths using a specific runtime. The return
 * value is an object containing an array of the functions found (`functions`)
 * and an array with the paths that haven't been recognized by the runtime
 * (`remainingPaths`).
 */
const findFunctionsInRuntime = async function ({ dedupe = false, featureFlags, fsCache, paths, runtime, }) {
    const functions = await runtime.findFunctionsInPaths({ featureFlags, fsCache, paths });
    // If `dedupe` is true, we use the function name (`filename`) as the map key,
    // so that `function-1.js` will overwrite `function-1.go`. Otherwise, we use
    // `srcPath`, so that both functions are returned.
    const key = dedupe ? 'name' : 'srcPath';
    // Augmenting the function objects with additional information.
    const augmentedFunctions = functions.map((func) => [
        func[key],
        {
            ...func,
            extension: (0, path_1.extname)(func.mainFile),
            filename: (0, path_1.basename)(func.srcPath),
            runtime,
        },
    ]);
    const usedPaths = new Set(augmentedFunctions.map(([path]) => path));
    const remainingPaths = paths.filter((path) => !usedPaths.has(path));
    return { functions: augmentedFunctions, remainingPaths };
};
// An object to cache filesystem operations. This allows different functions
// to perform IO operations on the same file (i.e. getting its stats or its
// contents) without duplicating work.
const makeFsCache = () => ({});
// The order of this array determines the priority of the runtimes. If a path
// is used by the first time, it won't be made available to the subsequent
// runtimes.
const RUNTIMES = [index_js_2.default, index_js_1.default, index_js_3.default];
/**
 * Gets a list of functions found in a list of paths.
 */
const getFunctionsFromPaths = async (paths, { config, dedupe = false, featureFlags = feature_flags_js_1.defaultFlags, } = {}) => {
    const fsCache = makeFsCache();
    // We cycle through the ordered array of runtimes, passing each one of them
    // through `findFunctionsInRuntime`. For each iteration, we collect all the
    // functions found plus the list of paths that still need to be evaluated,
    // using them as the input for the next iteration until the last runtime.
    const { functions } = await RUNTIMES.reduce(async (aggregate, runtime) => {
        const { functions: aggregateFunctions, remainingPaths: aggregatePaths } = await aggregate;
        const { functions: runtimeFunctions, remainingPaths: runtimePaths } = await findFunctionsInRuntime({
            dedupe,
            featureFlags,
            fsCache,
            paths: aggregatePaths,
            runtime,
        });
        return {
            functions: [...aggregateFunctions, ...runtimeFunctions],
            remainingPaths: runtimePaths,
        };
    }, Promise.resolve({ functions: [], remainingPaths: paths }));
    const functionsWithConfig = functions.map(([name, func]) => [
        name,
        { ...func, config: (0, config_js_1.getConfigForFunction)({ config, func }) },
    ]);
    return new Map(functionsWithConfig);
};
exports.getFunctionsFromPaths = getFunctionsFromPaths;
/**
 * Gets a list of functions found in a list of paths.
 */
const getFunctionFromPath = async (path, { config, featureFlags = feature_flags_js_1.defaultFlags } = {}) => {
    const fsCache = makeFsCache();
    for (const runtime of RUNTIMES) {
        const func = await runtime.findFunctionInPath({ path, fsCache, featureFlags });
        if (func) {
            return {
                ...func,
                runtime,
                config: (0, config_js_1.getConfigForFunction)({ config, func: { ...func, runtime } }),
            };
        }
    }
    return undefined;
};
exports.getFunctionFromPath = getFunctionFromPath;
//# sourceMappingURL=index.js.map