"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findFunctionInPath = exports.findFunctionsInPaths = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const locate_path_1 = __importDefault(require("locate-path"));
const non_nullable_js_1 = require("../../utils/non_nullable.js");
// List of extensions that this runtime will look for, in order of precedence.
const allowedExtensions = ['.js', '.zip', '.cjs', '.mjs', '.ts'];
// Sorting function, compatible with the callback of Array.sort, which sorts
// entries by extension according to their position in `allowedExtensions`.
// It places extensions with a higher precedence last in the array, so that
// they "win" when the array is flattened into a Map.
const sortByExtension = (fA, fB) => {
    const indexA = allowedExtensions.indexOf(fA.extension);
    const indexB = allowedExtensions.indexOf(fB.extension);
    return indexB - indexA;
};
const findFunctionsInPaths = async function ({ paths, fsCache, featureFlags }) {
    const functions = await Promise.all(paths.map((path) => (0, exports.findFunctionInPath)({ path, fsCache, featureFlags })));
    // It's fine to mutate the array since its scope is local to this function.
    const sortedFunctions = functions.filter(non_nullable_js_1.nonNullable).sort((fA, fB) => {
        // We first sort the functions array to put directories first. This is so
        // that `{name}/{name}.js` takes precedence over `{name}.js`.
        const directorySort = Number(fA.stat.isDirectory()) - Number(fB.stat.isDirectory());
        if (directorySort !== 0) {
            return directorySort;
        }
        // If the functions have the same name, we sort them according to the order
        // defined in `allowedExtensions`.
        if (fA.name === fB.name) {
            return sortByExtension(fA, fB);
        }
        return 0;
    });
    return sortedFunctions;
};
exports.findFunctionsInPaths = findFunctionsInPaths;
const findFunctionInPath = async function ({ path: srcPath }) {
    const filename = (0, path_1.basename)(srcPath);
    if (filename === 'node_modules') {
        return;
    }
    const stat = await fs_1.promises.lstat(srcPath);
    const mainFile = await getMainFile(srcPath, filename, stat);
    if (mainFile === undefined) {
        return;
    }
    const extension = (0, path_1.extname)(srcPath);
    const srcDir = stat.isDirectory() ? srcPath : (0, path_1.dirname)(srcPath);
    const name = (0, path_1.basename)(srcPath, (0, path_1.extname)(srcPath));
    return { extension, filename, mainFile, name, srcDir, srcPath, stat };
};
exports.findFunctionInPath = findFunctionInPath;
// Each `srcPath` can also be a directory with an `index` file or a file using
// the same filename as its directory.
const getMainFile = async function (srcPath, filename, stat) {
    if (stat.isDirectory()) {
        return await (0, locate_path_1.default)([
            (0, path_1.join)(srcPath, `${filename}.js`),
            (0, path_1.join)(srcPath, 'index.js'),
            (0, path_1.join)(srcPath, `${filename}.mjs`),
            (0, path_1.join)(srcPath, 'index.mjs'),
            (0, path_1.join)(srcPath, `${filename}.ts`),
            (0, path_1.join)(srcPath, 'index.ts'),
        ], { type: 'file' });
    }
    const extension = (0, path_1.extname)(srcPath);
    if (allowedExtensions.includes(extension)) {
        return srcPath;
    }
};
//# sourceMappingURL=finder.js.map