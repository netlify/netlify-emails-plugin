"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processESM = void 0;
const path_1 = require("path");
const fs_js_1 = require("../../../../utils/fs.js");
const node_version_js_1 = require("../../utils/node_version.js");
const package_json_js_1 = require("../../utils/package_json.js");
const transpile_js_1 = require("./transpile.js");
const getPatchedESMPackages = async (packages, fsCache) => {
    const patchedPackages = await Promise.all(packages.map((path) => patchESMPackage(path, fsCache)));
    const patchedPackagesMap = new Map();
    packages.forEach((packagePath, index) => {
        patchedPackagesMap.set(packagePath, patchedPackages[index]);
    });
    return patchedPackagesMap;
};
const isEntrypointESM = ({ basePath, esmPaths, mainFile, }) => {
    const absoluteESMPaths = new Set([...esmPaths].map((path) => resolvePath(path, basePath)));
    const entrypointIsESM = absoluteESMPaths.has(mainFile);
    return entrypointIsESM;
};
const patchESMPackage = async (path, fsCache) => {
    const file = (await (0, fs_js_1.cachedReadFile)(fsCache, path, 'utf8'));
    const packageJson = JSON.parse(file);
    const patchedPackageJson = {
        ...packageJson,
        type: 'commonjs',
    };
    return JSON.stringify(patchedPackageJson);
};
const processESM = async ({ basePath, config, esmPaths, featureFlags, fsCache, mainFile, reasons, name, }) => {
    const entrypointIsESM = isEntrypointESM({ basePath, esmPaths, mainFile });
    if (!entrypointIsESM) {
        return {
            moduleFormat: 'cjs',
        };
    }
    const packageJson = await (0, package_json_js_1.getPackageJsonIfAvailable)((0, path_1.dirname)(mainFile));
    const nodeSupport = (0, node_version_js_1.getNodeSupportMatrix)(config.nodeVersion);
    if (featureFlags.zisi_pure_esm && packageJson.type === 'module' && nodeSupport.esm) {
        return {
            moduleFormat: 'esm',
        };
    }
    const rewrites = await transpileESM({ basePath, config, esmPaths, fsCache, reasons, name });
    return {
        moduleFormat: 'cjs',
        rewrites,
    };
};
exports.processESM = processESM;
const resolvePath = (relativePath, basePath) => basePath ? (0, path_1.resolve)(basePath, relativePath) : (0, path_1.resolve)(relativePath);
const shouldTranspile = (path, cache, esmPaths, reasons) => {
    if (cache.has(path)) {
        return cache.get(path);
    }
    const reason = reasons.get(path);
    // This isn't an expected case, but if the path doesn't exist in `reasons` we
    // don't transpile it.
    if (reason === undefined) {
        cache.set(path, false);
        return false;
    }
    const { parents } = reason;
    const parentPaths = [...parents].filter((parentPath) => parentPath !== path);
    // If the path is an entrypoint, we transpile it only if it's an ESM file.
    if (parentPaths.length === 0) {
        const isESM = esmPaths.has(path);
        cache.set(path, isESM);
        return isESM;
    }
    // The path should be transpiled if every parent will also be transpiled, or
    // if there is no parent.
    const shouldTranspilePath = parentPaths.every((parentPath) => shouldTranspile(parentPath, cache, esmPaths, reasons));
    cache.set(path, shouldTranspilePath);
    return shouldTranspilePath;
};
const transpileESM = async ({ basePath, config, esmPaths, fsCache, reasons, name, }) => {
    const cache = new Map();
    const pathsToTranspile = [...esmPaths].filter((path) => shouldTranspile(path, cache, esmPaths, reasons));
    const pathsToTranspileSet = new Set(pathsToTranspile);
    const packageJsonPaths = [...reasons.entries()]
        .filter(([path, reason]) => {
        if ((0, path_1.basename)(path) !== 'package.json') {
            return false;
        }
        const needsPatch = [...reason.parents].some((parentPath) => pathsToTranspileSet.has(parentPath));
        return needsPatch;
    })
        .map(([path]) => (basePath ? (0, path_1.resolve)(basePath, path) : (0, path_1.resolve)(path)));
    const rewrites = await getPatchedESMPackages(packageJsonPaths, fsCache);
    await Promise.all(pathsToTranspile.map(async (path) => {
        const absolutePath = resolvePath(path, basePath);
        const transpiled = await (0, transpile_js_1.transpile)(absolutePath, config, name);
        rewrites.set(absolutePath, transpiled);
    }));
    return rewrites;
};
//# sourceMappingURL=es_modules.js.map