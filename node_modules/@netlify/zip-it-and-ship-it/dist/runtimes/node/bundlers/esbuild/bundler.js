"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleJsFile = exports.ESBUILD_LOG_LIMIT = void 0;
const path_1 = require("path");
const esbuild_1 = require("@netlify/esbuild");
const tmp_promise_1 = require("tmp-promise");
const error_js_1 = require("../../../../utils/error.js");
const fs_js_1 = require("../../../../utils/fs.js");
const bundler_target_js_1 = require("./bundler_target.js");
const plugin_dynamic_imports_js_1 = require("./plugin_dynamic_imports.js");
const plugin_native_modules_js_1 = require("./plugin_native_modules.js");
const plugin_node_builtin_js_1 = require("./plugin_node_builtin.js");
// Maximum number of log messages that an esbuild instance will produce. This
// limit is important to avoid out-of-memory errors due to too much data being
// sent in the Go<>Node IPC channel.
exports.ESBUILD_LOG_LIMIT = 10;
// When resolving imports with no extension (e.g. require('./foo')), these are
// the extensions that esbuild will look for, in this order.
const RESOLVE_EXTENSIONS = ['.js', '.jsx', '.mjs', '.cjs', '.ts', '.json'];
// eslint-disable-next-line max-statements
const bundleJsFile = async function ({ additionalModulePaths, basePath, config, externalModules = [], featureFlags, ignoredModules = [], name, srcDir, srcFile, }) {
    // We use a temporary directory as the destination for esbuild files to avoid
    // any naming conflicts with files generated by other functions.
    const targetDirectory = await (0, tmp_promise_1.tmpName)();
    // De-duping external and ignored modules.
    const external = [...new Set([...externalModules, ...ignoredModules])];
    // To be populated by the native modules plugin with the names, versions and
    // paths of any Node modules with native dependencies.
    const nativeNodeModules = {};
    // To be populated by the dynamic imports plugin with the names of the Node
    // modules that include imports with dynamic expressions.
    const nodeModulesWithDynamicImports = new Set();
    // To be populated by the dynamic imports plugin with any paths (in a glob
    // format) to be included in the bundle in order to make a dynamic import
    // work at runtime.
    const dynamicImportsIncludedPaths = new Set();
    // The list of esbuild plugins to enable for this build.
    const plugins = [
        (0, plugin_node_builtin_js_1.getNodeBuiltinPlugin)(),
        (0, plugin_native_modules_js_1.getNativeModulesPlugin)(nativeNodeModules),
        (0, plugin_dynamic_imports_js_1.getDynamicImportsPlugin)({
            basePath,
            includedPaths: dynamicImportsIncludedPaths,
            moduleNames: nodeModulesWithDynamicImports,
            processImports: config.processDynamicNodeImports !== false,
            srcDir,
        }),
    ];
    // The version of ECMAScript to use as the build target. This will determine
    // whether certain features are transpiled down or left untransformed.
    const nodeTarget = (0, bundler_target_js_1.getBundlerTarget)(config.nodeVersion);
    // esbuild will format `sources` relative to the sourcemap file, which lives
    // in `destFolder`. We use `sourceRoot` to establish that relation. They are
    // URLs, not paths, so even on Windows they should use forward slashes.
    const sourceRoot = targetDirectory.replace(/\\/g, '/');
    // Configuring the output format of esbuild. The `includedFiles` array we get
    // here contains additional paths to include with the bundle, like the path
    // to a `package.json` with {"type": "module"} in case of an ESM function.
    const { includedFiles: includedFilesFromModuleDetection, moduleFormat } = await (0, bundler_target_js_1.getModuleFormat)(srcDir, featureFlags, config.nodeVersion);
    try {
        const { metafile = { inputs: {}, outputs: {} }, warnings } = await (0, esbuild_1.build)({
            bundle: true,
            entryPoints: [srcFile],
            external,
            format: moduleFormat,
            logLevel: 'warning',
            logLimit: exports.ESBUILD_LOG_LIMIT,
            metafile: true,
            nodePaths: additionalModulePaths,
            outdir: targetDirectory,
            platform: 'node',
            plugins,
            resolveExtensions: RESOLVE_EXTENSIONS,
            sourcemap: Boolean(config.nodeSourcemap),
            sourceRoot,
            target: [nodeTarget],
        });
        const bundlePaths = getBundlePaths({
            destFolder: targetDirectory,
            outputs: metafile.outputs,
            srcFile,
        });
        const inputs = Object.keys(metafile.inputs).map((path) => (0, path_1.resolve)(path));
        const cleanTempFiles = getCleanupFunction([...bundlePaths.keys()]);
        const additionalPaths = [...dynamicImportsIncludedPaths, ...includedFilesFromModuleDetection];
        return {
            additionalPaths,
            bundlePaths,
            cleanTempFiles,
            inputs,
            moduleFormat,
            nativeNodeModules,
            nodeModulesWithDynamicImports: [...nodeModulesWithDynamicImports],
            warnings,
        };
    }
    catch (error) {
        throw error_js_1.FunctionBundlingUserError.addCustomErrorInfo(error, { functionName: name, runtime: 'js', bundler: 'esbuild' });
    }
};
exports.bundleJsFile = bundleJsFile;
// Takes the `outputs` object produced by esbuild and returns a Map with the
// absolute paths of the generated files as keys, and the paths that those
// files should take in the generated bundle as values. This is compatible
// with the `aliases` format used upstream.
const getBundlePaths = ({ destFolder, outputs, srcFile, }) => {
    const bundleFilename = `${(0, path_1.basename)(srcFile, (0, path_1.extname)(srcFile))}.js`;
    const mainFileDirectory = (0, path_1.dirname)(srcFile);
    const bundlePaths = new Map();
    // The paths returned by esbuild are relative to the current directory, which
    // is a problem on Windows if the target directory is in a different drive
    // letter. To get around that, instead of using `path.resolve`, we compute
    // the absolute path by joining `destFolder` with the `basename` of each
    // entry of the `outputs` object.
    Object.entries(outputs).forEach(([path, output]) => {
        const filename = (0, path_1.basename)(path);
        const extension = (0, path_1.extname)(path);
        const absolutePath = (0, path_1.join)(destFolder, filename);
        if (output.entryPoint && (0, path_1.basename)(output.entryPoint) === (0, path_1.basename)(srcFile)) {
            // Ensuring the main file has a `.js` extension.
            const normalizedSrcFile = (0, fs_js_1.getPathWithExtension)(srcFile, '.js');
            bundlePaths.set(absolutePath, normalizedSrcFile);
        }
        else if (extension === '.js' || filename === `${bundleFilename}.map`) {
            bundlePaths.set(absolutePath, (0, path_1.join)(mainFileDirectory, filename));
        }
    });
    return bundlePaths;
};
const getCleanupFunction = (paths) => async () => {
    await Promise.all(paths.filter(Boolean).map(fs_js_1.safeUnlink));
};
//# sourceMappingURL=bundler.js.map