"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSrcFiles = void 0;
/* eslint-disable max-lines */
const path_1 = require("path");
const junk_1 = require("junk");
const precinct_1 = __importDefault(require("precinct"));
const non_nullable_js_1 = require("../../../../utils/non_nullable.js");
const included_files_js_1 = require("../../utils/included_files.js");
const package_json_js_1 = require("../../utils/package_json.js");
const traversal_cache_js_1 = require("../../utils/traversal_cache.js");
const list_imports_js_1 = require("./list_imports.js");
const resolve_js_1 = require("./resolve.js");
const traverse_js_1 = require("./traverse.js");
const tree_files_js_1 = require("./tree_files.js");
const tree_shake_js_1 = require("./tree_shake.js");
// Retrieve the paths to the Node.js files to zip.
// We only include the files actually needed by the function because AWS Lambda
// has a size limit for the zipped file. It also makes cold starts faster.
const getSrcFiles = async function ({ config, featureFlags, mainFile, name, pluginsModulesPath, srcDir, srcPath, stat, }) {
    const { includedFiles = [], includedFilesBasePath } = config;
    const { excludePatterns, paths: includedFilePaths } = await (0, included_files_js_1.getPathsOfIncludedFiles)(includedFiles, includedFilesBasePath);
    const [treeFiles, depFiles] = await Promise.all([
        (0, tree_files_js_1.getTreeFiles)(srcPath, stat),
        getDependencies({ featureFlags, functionName: name, mainFile, pluginsModulesPath, srcDir }),
    ]);
    const files = [...treeFiles, ...depFiles].map(path_1.normalize);
    const uniqueFiles = [...new Set(files)];
    // We sort so that the archive's checksum is deterministic.
    // Mutating is fine since `Array.filter()` returns a shallow copy
    const filteredFiles = uniqueFiles.filter(isNotJunk).sort();
    const srcFiles = (0, included_files_js_1.filterExcludedPaths)(filteredFiles, excludePatterns);
    const includedPaths = (0, included_files_js_1.filterExcludedPaths)(includedFilePaths, excludePatterns);
    return { srcFiles: [...srcFiles, ...includedPaths], includedFiles: includedPaths };
};
exports.getSrcFiles = getSrcFiles;
// Remove temporary files like *~, *.swp, etc.
const isNotJunk = function (file) {
    return (0, junk_1.not)((0, path_1.basename)(file));
};
// Retrieve all the files recursively required by a Node.js file
const getDependencies = async function ({ featureFlags, functionName, mainFile, pluginsModulesPath, srcDir, }) {
    const packageJson = await (0, package_json_js_1.getPackageJson)(srcDir);
    const state = (0, traversal_cache_js_1.getNewCache)();
    try {
        return await getFileDependencies({
            featureFlags,
            functionName,
            path: mainFile,
            packageJson,
            pluginsModulesPath,
            state,
        });
    }
    catch (error) {
        error.message = `In file "${mainFile}"\n${error.message}`;
        throw error;
    }
};
const getFileDependencies = async function ({ featureFlags, functionName, path, packageJson, pluginsModulesPath, state, treeShakeNext = false, }) {
    if (state.localFiles.has(path)) {
        return [];
    }
    state.localFiles.add(path);
    const basedir = (0, path_1.dirname)(path);
    const dependencies = featureFlags.parseWithEsbuild
        ? await (0, list_imports_js_1.listImports)({ functionName, path })
        : await precinct_1.default.paperwork(path, { includeCore: false });
    const depsPaths = await Promise.all(dependencies.filter(non_nullable_js_1.nonNullable).map((dependency) => getImportDependencies({
        dependency,
        basedir,
        featureFlags,
        functionName,
        packageJson,
        pluginsModulesPath,
        state,
        treeShakeNext,
    })));
    return depsPaths.flat();
};
const getImportDependencies = function ({ dependency, basedir, featureFlags, functionName, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    const shouldTreeShakeNext = treeShakeNext || isNextOnNetlify(dependency);
    if ((0, tree_shake_js_1.shouldTreeShake)(dependency, shouldTreeShakeNext)) {
        return getTreeShakedDependencies({
            dependency,
            basedir,
            featureFlags,
            functionName,
            packageJson,
            pluginsModulesPath,
            state,
            treeShakeNext: shouldTreeShakeNext,
        });
    }
    return (0, traverse_js_1.getDependencyPathsForDependency)({ dependency, basedir, state, packageJson, pluginsModulesPath });
};
const isNextOnNetlify = function (dependency) {
    return (0, path_1.basename)(dependency, '.js') === 'renderNextPage';
};
// When a file requires another one, we apply the top-level logic recursively
const getTreeShakedDependencies = async function ({ dependency, basedir, featureFlags, functionName, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    const path = await (0, resolve_js_1.resolvePathPreserveSymlinks)(dependency, [basedir, pluginsModulesPath].filter(non_nullable_js_1.nonNullable));
    const depsPath = await getFileDependencies({
        featureFlags,
        functionName,
        path,
        packageJson,
        pluginsModulesPath,
        state,
        treeShakeNext,
    });
    return [path, ...depsPath];
};
/* eslint-enable max-lines */
//# sourceMappingURL=src_files.js.map