"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBindingsMethod = void 0;
const getBindingFromVariableDeclaration = function (node, bindings) {
    node.declarations.forEach((declaration) => {
        if (declaration.id.type === 'Identifier' && declaration.init) {
            bindings.set(declaration.id.name, declaration.init);
        }
    });
};
const getBindingsFromNode = function (node, bindings) {
    var _a;
    if (node.type === 'VariableDeclaration') {
        // A variable was created, so create it and store the potential value
        getBindingFromVariableDeclaration(node, bindings);
    }
    else if (node.type === 'ExpressionStatement' &&
        node.expression.type === 'AssignmentExpression' &&
        node.expression.left.type === 'Identifier') {
        // The variable was reassigned, so let's store the new value
        bindings.set(node.expression.left.name, node.expression.right);
    }
    else if (node.type === 'ExportNamedDeclaration' && ((_a = node.declaration) === null || _a === void 0 ? void 0 : _a.type) === 'VariableDeclaration') {
        // A `export const|let ...` creates a binding that can later be referenced again
        getBindingFromVariableDeclaration(node.declaration, bindings);
    }
};
/**
 * Goes through all relevant nodes and creates a map from binding name to assigned value/expression
 */
const getAllBindings = function (nodes) {
    const bindings = new Map();
    nodes.forEach((node) => {
        getBindingsFromNode(node, bindings);
    });
    return bindings;
};
const createBindingsMethod = function (nodes) {
    // memoize the result for these nodes
    let result;
    return () => {
        if (!result) {
            result = getAllBindings(nodes);
        }
        return result;
    };
};
exports.createBindingsMethod = createBindingsMethod;
//# sourceMappingURL=bindings.js.map