"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safelyParseFile = exports.parseExpression = void 0;
/* eslint-disable max-lines */
const fs_1 = require("fs");
const path_1 = require("path");
const parser_1 = require("@babel/parser");
const non_nullable_js_1 = require("../../../utils/non_nullable.js");
const GLOB_WILDCARD = '**';
// Transforms an array of glob nodes into a glob string including an absolute
// path.
//
// Example: ["./files/", "*", ".json"] => "/home/ntl/files/*.json"
const getAbsoluteGlob = ({ basePath, globNodes, resolveDir, }) => {
    if (!validateGlobNodes(globNodes)) {
        return null;
    }
    const globStarIndex = globNodes.indexOf(GLOB_WILDCARD);
    const [staticPath, dynamicPath] = globStarIndex === -1
        ? [globNodes.join(''), '']
        : [globNodes.slice(0, globStarIndex).join(''), globNodes.slice(globStarIndex).join('')];
    const absoluteStaticPath = (0, path_1.resolve)(resolveDir, staticPath);
    const relativeStaticPath = (0, path_1.relative)(basePath, absoluteStaticPath);
    const absoluteGlob = (0, path_1.join)(relativeStaticPath, dynamicPath);
    return absoluteGlob;
};
// Returns GLOB_WILDCARD for AST nodes that are accepted as part of a dynamic
// expression and convertable to a wildcard character. This determines whether
// we convert an expression or leave it alone. For example:
//
// - `./files/${someVariable}`: Convert `someVariable` to GLOB_WILDCARD
// - `./files/${[some, array]}`: Don't convert expression
//
// The following AST nodes are converted to a wildcard:
//
// - CallExpression: `someFunction()`
// - ConditionalExpression: `someCond ? someValue : otherValue`
// - Identifier: `someVariable`
// - MemberExpression: `someArray[index]` or `someObject.property`
const getWildcardFromASTNode = (node) => {
    switch (node.type) {
        case 'CallExpression':
        case 'ConditionalExpression':
        case 'Identifier':
        case 'MemberExpression':
            return GLOB_WILDCARD;
        default:
            throw new Error('Expression member not supported');
    }
};
// Tries to parse an expression, returning an object with:
// - `includedPathsGlob`: A glob with the files to be included in the bundle
// - `type`: The expression type (e.g. "require", "import")
const parseExpression = ({ basePath, expression: rawExpression, resolveDir, }) => {
    const { program } = (0, parser_1.parse)(rawExpression, {
        sourceType: 'module',
    });
    const [statement] = program.body;
    if (statement.type !== 'ExpressionStatement') {
        return;
    }
    const { expression } = statement;
    if (expression.type === 'CallExpression' &&
        expression.callee.type === 'Identifier' &&
        expression.callee.name === 'require') {
        try {
            const includedPathsGlob = parseRequire({ basePath, expression, resolveDir });
            return {
                includedPathsGlob,
                type: expression.callee.name,
            };
        }
        catch {
            // no-op
        }
    }
};
exports.parseExpression = parseExpression;
// Parses a JS/TS file and returns the resulting AST.
const parseFile = async (path) => {
    const code = await fs_1.promises.readFile(path, 'utf8');
    const ast = (0, parser_1.parse)(code, {
        plugins: ['typescript'],
        sourceType: 'module',
    });
    return ast.program;
};
// Attempts to parse a JS/TS file at the given path, returning its AST if
// successful, or `null` if not.
const safelyParseFile = async (path) => {
    if (!path) {
        return null;
    }
    try {
        return await parseFile(path);
    }
    catch {
        return null;
    }
};
exports.safelyParseFile = safelyParseFile;
// Parses a `require()` and returns a glob string with an absolute path.
const parseRequire = ({ basePath, expression, resolveDir, }) => {
    const { arguments: args = [] } = expression;
    const [firstArg] = args;
    if (firstArg === undefined) {
        return;
    }
    if (firstArg.type === 'BinaryExpression') {
        try {
            const globNodes = parseBinaryExpression(firstArg);
            return getAbsoluteGlob({ basePath, globNodes, resolveDir });
        }
        catch {
            // no-op
        }
    }
    if (firstArg.type === 'TemplateLiteral') {
        const globNodes = parseTemplateLiteral(firstArg);
        return getAbsoluteGlob({ basePath, globNodes, resolveDir });
    }
};
// Transforms a binary expression AST node into an array of glob nodes, where
// static parts will be left untouched and identifiers will be replaced by
// `GLOB_WILDCARD`.
//
// Example: './files/' + lang + '.json' => ["./files/", "**", ".json"]
const parseBinaryExpression = (expression) => {
    const { left, operator, right } = expression;
    if (operator !== '+') {
        throw new Error('Expression operator not supported');
    }
    const operands = [left, right].flatMap((operand) => {
        switch (operand.type) {
            case 'BinaryExpression':
                return parseBinaryExpression(operand);
            case 'StringLiteral':
                return operand.value;
            default:
                return getWildcardFromASTNode(operand);
        }
    });
    return operands;
};
// Transforms a template literal AST node into an array of glob nodes, where
// static parts will be left untouched and identifiers will be replaced by
// `GLOB_WILDCARD`.
//
// Example: `./files/${lang}.json` => ["./files/", "**", ".json"]
const parseTemplateLiteral = (expression) => {
    const { expressions, quasis } = expression;
    const parts = [...expressions, ...quasis].sort((partA, partB) => { var _a, _b; return ((_a = partA.start) !== null && _a !== void 0 ? _a : 0) - ((_b = partB.start) !== null && _b !== void 0 ? _b : 0); });
    const globNodes = parts.map((part) => {
        switch (part.type) {
            case 'TemplateElement':
                return part.value.cooked === '' ? null : part.value.cooked;
            default:
                return getWildcardFromASTNode(part);
        }
    });
    return globNodes.filter(non_nullable_js_1.nonNullable);
};
// For our purposes, we consider a glob to be valid if all the nodes are
// strings and the first node is static (i.e. not a wildcard character).
const validateGlobNodes = (globNodes) => {
    if (!globNodes) {
        return false;
    }
    const hasStrings = globNodes.every((node) => typeof node === 'string');
    const hasStaticHead = globNodes[0] !== GLOB_WILDCARD;
    return hasStrings && hasStaticHead;
};
/* eslint-enable max-lines */
//# sourceMappingURL=index.js.map