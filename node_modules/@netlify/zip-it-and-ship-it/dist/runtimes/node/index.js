"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const cp_file_1 = __importDefault(require("cp-file"));
const index_js_1 = require("./bundlers/index.js");
const finder_js_1 = require("./finder.js");
const index_js_2 = require("./in_source_config/index.js");
const plugin_modules_path_js_1 = require("./utils/plugin_modules_path.js");
const zip_js_1 = require("./utils/zip.js");
// A proxy for the `getSrcFiles` function which adds a default `bundler` using
// the `getDefaultBundler` function.
const getSrcFilesWithBundler = async (parameters) => {
    const pluginsModulesPath = await (0, plugin_modules_path_js_1.getPluginsModulesPath)(parameters.srcDir);
    const bundlerName = parameters.config.nodeBundler ||
        (await (0, index_js_1.getDefaultBundler)({
            extension: parameters.extension,
            featureFlags: parameters.featureFlags,
            mainFile: parameters.mainFile,
        }));
    const bundler = (0, index_js_1.getBundler)(bundlerName);
    const result = await bundler.getSrcFiles({ ...parameters, pluginsModulesPath });
    return result.srcFiles;
};
const zipFunction = async function ({ archiveFormat, basePath, config = {}, destFolder, extension, featureFlags, filename, mainFile, name, repositoryRoot, runtime, srcDir, srcPath, stat, }) {
    const pluginsModulesPath = await (0, plugin_modules_path_js_1.getPluginsModulesPath)(srcDir);
    const bundlerName = config.nodeBundler || (await (0, index_js_1.getDefaultBundler)({ extension, mainFile, featureFlags }));
    const bundler = (0, index_js_1.getBundler)(bundlerName);
    // If the file is a zip, we assume the function is bundled and ready to go.
    // We simply copy it to the destination path with no further processing.
    if (extension === '.zip') {
        const destPath = (0, path_1.join)(destFolder, filename);
        await (0, cp_file_1.default)(srcPath, destPath);
        return { config, path: destPath };
    }
    const { aliases = new Map(), cleanupFunction, basePath: finalBasePath, bundlerWarnings, includedFiles, inputs, mainFile: finalMainFile = mainFile, moduleFormat, nativeNodeModules, nodeModulesWithDynamicImports, rewrites, srcFiles, } = await bundler.bundle({
        basePath,
        config,
        extension,
        featureFlags,
        filename,
        mainFile,
        name,
        pluginsModulesPath,
        repositoryRoot,
        runtime,
        srcDir,
        srcPath,
        stat,
    });
    const inSourceConfig = await (0, index_js_2.findISCDeclarationsInPath)(mainFile, name);
    (0, plugin_modules_path_js_1.createAliases)(srcFiles, pluginsModulesPath, aliases, finalBasePath);
    const zipPath = await (0, zip_js_1.zipNodeJs)({
        aliases,
        archiveFormat,
        basePath: finalBasePath,
        destFolder,
        extension,
        filename,
        mainFile: finalMainFile,
        moduleFormat,
        rewrites,
        srcFiles,
    });
    await (cleanupFunction === null || cleanupFunction === void 0 ? void 0 : cleanupFunction());
    return {
        bundler: bundlerName,
        bundlerWarnings,
        config,
        inputs,
        includedFiles,
        inSourceConfig,
        nativeNodeModules,
        nodeModulesWithDynamicImports,
        path: zipPath,
    };
};
const zipWithFunctionWithFallback = async ({ config = {}, ...parameters }) => {
    // If a specific JS bundler version is specified, we'll use it.
    if (config.nodeBundler !== 'esbuild_zisi') {
        return zipFunction({ ...parameters, config });
    }
    // Otherwise, we'll try to bundle with esbuild and, if that fails, fallback
    // to zisi.
    try {
        return await zipFunction({ ...parameters, config: { ...config, nodeBundler: 'esbuild' } });
    }
    catch (esbuildError) {
        try {
            const data = await zipFunction({ ...parameters, config: { ...config, nodeBundler: 'zisi' } });
            return { ...data, bundlerErrors: esbuildError.errors };
        }
        catch {
            throw esbuildError;
        }
    }
};
const runtime = {
    findFunctionsInPaths: finder_js_1.findFunctionsInPaths,
    findFunctionInPath: finder_js_1.findFunctionInPath,
    getSrcFiles: getSrcFilesWithBundler,
    name: 'js',
    zipFunction: zipWithFunctionWithFallback,
};
exports.default = runtime;
//# sourceMappingURL=index.js.map