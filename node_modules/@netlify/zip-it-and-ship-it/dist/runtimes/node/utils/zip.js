"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipNodeJs = void 0;
const buffer_1 = require("buffer");
const fs_1 = require("fs");
const os_1 = __importDefault(require("os"));
const path_1 = require("path");
const cp_file_1 = __importDefault(require("cp-file"));
const del_1 = __importDefault(require("del"));
const p_map_1 = __importDefault(require("p-map"));
const archive_js_1 = require("../../../archive.js");
const fs_js_1 = require("../../../utils/fs.js");
const entry_file_js_1 = require("./entry_file.js");
const normalize_path_js_1 = require("./normalize_path.js");
// Taken from https://www.npmjs.com/package/cpy.
const COPY_FILE_CONCURRENCY = os_1.default.cpus().length === 0 ? 2 : os_1.default.cpus().length * 2;
// Sub-directory to place all user-defined files  (i.e. everything other than
// the entry file generated by zip-it-and-ship-it).
const DEFAULT_USER_SUBDIRECTORY = 'src';
const createDirectory = async function ({ aliases = new Map(), basePath, destFolder, extension, filename, mainFile, moduleFormat, rewrites = new Map(), srcFiles, }) {
    const { contents: entryContents, filename: entryFilename } = (0, entry_file_js_1.getEntryFile)({
        commonPrefix: basePath,
        filename,
        mainFile,
        moduleFormat,
        userNamespace: DEFAULT_USER_SUBDIRECTORY,
    });
    const functionFolder = (0, path_1.join)(destFolder, (0, path_1.basename)(filename, extension));
    // Deleting the functions directory in case it exists before creating it.
    await (0, del_1.default)(functionFolder, { force: true });
    await fs_1.promises.mkdir(functionFolder, { recursive: true });
    // Writing entry file.
    await fs_1.promises.writeFile((0, path_1.join)(functionFolder, entryFilename), entryContents);
    // Copying source files.
    await (0, p_map_1.default)(srcFiles, (srcFile) => {
        const destPath = aliases.get(srcFile) || srcFile;
        const normalizedDestPath = (0, normalize_path_js_1.normalizeFilePath)({
            commonPrefix: basePath,
            path: destPath,
            userNamespace: DEFAULT_USER_SUBDIRECTORY,
        });
        const absoluteDestPath = (0, path_1.join)(functionFolder, normalizedDestPath);
        if (rewrites.has(srcFile)) {
            return (0, fs_js_1.mkdirAndWriteFile)(absoluteDestPath, rewrites.get(srcFile));
        }
        return (0, cp_file_1.default)(srcFile, absoluteDestPath);
    }, { concurrency: COPY_FILE_CONCURRENCY });
    return functionFolder;
};
const createZipArchive = async function ({ aliases, basePath, destFolder, extension, filename, mainFile, moduleFormat, rewrites, srcFiles, }) {
    const destPath = (0, path_1.join)(destFolder, `${(0, path_1.basename)(filename, extension)}.zip`);
    const { archive, output } = (0, archive_js_1.startZip)(destPath);
    const entryFilename = `${(0, path_1.basename)(filename, extension)}.js`;
    const entryFilePath = (0, path_1.resolve)(basePath, entryFilename);
    // We don't need an entry file if it would end up with the same path as the
    // function's main file.
    const needsEntryFile = entryFilePath !== mainFile;
    // There is a naming conflict with the entry file if one of the supporting
    // files (i.e. not the main file) has the path that the entry file needs to
    // take.
    const hasEntryFileConflict = srcFiles.some((srcFile) => srcFile === entryFilePath && srcFile !== mainFile);
    // If there is a naming conflict, we move all user files (everything other
    // than the entry file) to its own sub-directory.
    const userNamespace = hasEntryFileConflict ? DEFAULT_USER_SUBDIRECTORY : '';
    if (needsEntryFile) {
        const entryFile = (0, entry_file_js_1.getEntryFile)({ commonPrefix: basePath, filename, mainFile, moduleFormat, userNamespace });
        addEntryFileToZip(archive, entryFile);
    }
    const srcFilesInfos = await Promise.all(srcFiles.map(addStat));
    // We ensure this is not async, so that the archive's checksum is
    // deterministic. Otherwise it depends on the order the files were added.
    srcFilesInfos.forEach(({ srcFile, stat }) => {
        zipJsFile({
            aliases,
            archive,
            commonPrefix: basePath,
            rewrites,
            srcFile,
            stat,
            userNamespace,
        });
    });
    await (0, archive_js_1.endZip)(archive, output);
    return destPath;
};
const zipNodeJs = function ({ archiveFormat, ...options }) {
    if (archiveFormat === 'zip') {
        return createZipArchive(options);
    }
    return createDirectory(options);
};
exports.zipNodeJs = zipNodeJs;
const addEntryFileToZip = function (archive, { contents, filename }) {
    const contentBuffer = buffer_1.Buffer.from(contents);
    (0, archive_js_1.addZipContent)(archive, contentBuffer, filename);
};
const addStat = async function (srcFile) {
    const stat = await fs_1.promises.lstat(srcFile);
    return { srcFile, stat };
};
const zipJsFile = function ({ aliases = new Map(), archive, commonPrefix, rewrites = new Map(), stat, srcFile, userNamespace, }) {
    const destPath = aliases.get(srcFile) || srcFile;
    const normalizedDestPath = (0, normalize_path_js_1.normalizeFilePath)({ commonPrefix, path: destPath, userNamespace });
    if (rewrites.has(srcFile)) {
        (0, archive_js_1.addZipContent)(archive, rewrites.get(srcFile), normalizedDestPath);
    }
    else {
        (0, archive_js_1.addZipFile)(archive, srcFile, normalizedDestPath, stat);
    }
};
//# sourceMappingURL=zip.js.map