"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipFunction = exports.zipFunctions = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const p_map_1 = __importDefault(require("p-map"));
const feature_flags_js_1 = require("./feature_flags.js");
const manifest_js_1 = require("./manifest.js");
const index_js_1 = require("./runtimes/index.js");
const archive_size_js_1 = require("./utils/archive_size.js");
const format_result_js_1 = require("./utils/format_result.js");
const fs_js_1 = require("./utils/fs.js");
const non_nullable_js_1 = require("./utils/non_nullable.js");
const DEFAULT_PARALLEL_LIMIT = 5;
// TODO: now that we have types, do we still need runtime validation?
const validateArchiveFormat = (archiveFormat) => {
    if (!['none', 'zip'].includes(archiveFormat)) {
        throw new Error(`Invalid archive format: ${archiveFormat}`);
    }
};
// Zip `srcFolder/*` (Node.js or Go files) to `destFolder/*.zip` so it can be
// used by AWS Lambda
const zipFunctions = async function (relativeSrcFolders, destFolder, { archiveFormat = 'zip', basePath, config = {}, featureFlags: inputFeatureFlags, manifest, parallelLimit = DEFAULT_PARALLEL_LIMIT, repositoryRoot = basePath, } = {}) {
    validateArchiveFormat(archiveFormat);
    const featureFlags = (0, feature_flags_js_1.getFlags)(inputFeatureFlags);
    const srcFolders = (0, fs_js_1.resolveFunctionsDirectories)(relativeSrcFolders);
    const [paths] = await Promise.all([(0, fs_js_1.listFunctionsDirectories)(srcFolders), fs_1.promises.mkdir(destFolder, { recursive: true })]);
    const functions = await (0, index_js_1.getFunctionsFromPaths)(paths, { config, dedupe: true, featureFlags });
    const results = await (0, p_map_1.default)(functions.values(), async (func) => {
        const zipResult = await func.runtime.zipFunction({
            archiveFormat,
            basePath,
            config: func.config,
            destFolder,
            extension: func.extension,
            featureFlags,
            filename: func.filename,
            mainFile: func.mainFile,
            name: func.name,
            repositoryRoot,
            runtime: func.runtime,
            srcDir: func.srcDir,
            srcPath: func.srcPath,
            stat: func.stat,
        });
        return { ...zipResult, mainFile: func.mainFile, name: func.name, runtime: func.runtime };
    }, {
        concurrency: parallelLimit,
    });
    const formattedResults = await Promise.all(results.filter(non_nullable_js_1.nonNullable).map(async (result) => {
        const resultWithSize = await (0, archive_size_js_1.addArchiveSize)(result);
        return (0, format_result_js_1.formatZipResult)(resultWithSize);
    }));
    if (manifest !== undefined) {
        await (0, manifest_js_1.createManifest)({ functions: formattedResults, path: (0, path_1.resolve)(manifest) });
    }
    return formattedResults;
};
exports.zipFunctions = zipFunctions;
const zipFunction = async function (relativeSrcPath, destFolder, { archiveFormat = 'zip', basePath, config: inputConfig = {}, featureFlags: inputFeatureFlags, repositoryRoot = basePath, } = {}) {
    validateArchiveFormat(archiveFormat);
    const featureFlags = (0, feature_flags_js_1.getFlags)(inputFeatureFlags);
    const srcPath = (0, path_1.resolve)(relativeSrcPath);
    const functions = await (0, index_js_1.getFunctionsFromPaths)([srcPath], { config: inputConfig, dedupe: true, featureFlags });
    if (functions.size === 0) {
        return;
    }
    const { config, extension, filename, mainFile, name, runtime, srcDir, stat: stats, } = functions.values().next().value;
    await fs_1.promises.mkdir(destFolder, { recursive: true });
    const zipResult = await runtime.zipFunction({
        archiveFormat,
        basePath,
        config,
        destFolder,
        extension,
        featureFlags,
        filename,
        mainFile,
        name,
        repositoryRoot,
        runtime,
        srcDir,
        srcPath,
        stat: stats,
    });
    return (0, format_result_js_1.formatZipResult)({ ...zipResult, mainFile, name, runtime });
};
exports.zipFunction = zipFunction;
//# sourceMappingURL=zip.js.map