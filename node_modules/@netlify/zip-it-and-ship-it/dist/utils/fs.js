"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkdirAndWriteFile = exports.resolveFunctionsDirectories = exports.listFunctionsDirectories = exports.safeUnlink = exports.getPathWithExtension = exports.cachedReadFile = exports.cachedReaddir = exports.cachedLstat = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const non_nullable_js_1 = require("./non_nullable.js");
// This caches multiple FS calls to the same path. It creates a cache key with
// the name of the function and the path (e.g. "readdir:/some/directory").
//
// TODO: This abstraction is stripping out some type data. For example, when
// calling `readFile` without an encoding, the return type should be narrowed
// down from `string | Buffer` to `Buffer`, but that's not happening.
const makeCachedFunction = (func) => (cache, path, ...args) => {
    const key = `${func.name}:${path}`;
    if (cache[key] === undefined) {
        // eslint-disable-next-line no-param-reassign
        cache[key] = func(path, ...args);
    }
    return cache[key];
};
exports.cachedLstat = makeCachedFunction(fs_1.promises.lstat);
exports.cachedReaddir = makeCachedFunction(fs_1.promises.readdir);
exports.cachedReadFile = makeCachedFunction(fs_1.promises.readFile);
const getPathWithExtension = (path, extension) => (0, path_1.format)({ ...(0, path_1.parse)(path), base: undefined, ext: extension });
exports.getPathWithExtension = getPathWithExtension;
const safeUnlink = async (path) => {
    try {
        await fs_1.promises.unlink(path);
    }
    catch { }
};
exports.safeUnlink = safeUnlink;
// Takes a list of absolute paths and returns an array containing all the
// filenames within those directories, if at least one of the directories
// exists. If not, an error is thrown.
const listFunctionsDirectories = async function (srcFolders) {
    const filenamesByDirectory = await Promise.allSettled(srcFolders.map((srcFolder) => listFunctionsDirectory(srcFolder)));
    const errorMessages = [];
    const validDirectories = filenamesByDirectory
        .map((result) => {
        if (result.status === 'rejected') {
            // If the error is about `ENOENT` (FileNotFound) then we only throw later if this happens
            // for all directories.
            if (result.reason instanceof Error && result.reason.code === 'ENOENT') {
                return null;
            }
            // In any other error case besides `ENOENT` throw immediately
            throw result.reason;
        }
        return result.value;
    })
        .filter(non_nullable_js_1.nonNullable);
    if (validDirectories.length === 0) {
        throw new Error(`Functions folders do not exist: ${srcFolders.join(', ')}
${errorMessages.join('\n')}`);
    }
    return validDirectories.flat();
};
exports.listFunctionsDirectories = listFunctionsDirectories;
const listFunctionsDirectory = async function (srcFolder) {
    const filenames = await fs_1.promises.readdir(srcFolder);
    return filenames.map((name) => (0, path_1.join)(srcFolder, name));
};
const resolveFunctionsDirectories = (input) => {
    const directories = Array.isArray(input) ? input : [input];
    const absoluteDirectories = directories.map((srcFolder) => (0, path_1.resolve)(srcFolder));
    return absoluteDirectories;
};
exports.resolveFunctionsDirectories = resolveFunctionsDirectories;
const mkdirAndWriteFile = async (path, ...params) => {
    if (typeof path === 'string') {
        const directory = (0, path_1.dirname)(path);
        await fs_1.promises.mkdir(directory, { recursive: true });
    }
    return fs_1.promises.writeFile(path, ...params);
};
exports.mkdirAndWriteFile = mkdirAndWriteFile;
//# sourceMappingURL=fs.js.map